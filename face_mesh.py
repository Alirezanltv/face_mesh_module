# -*- coding: utf-8 -*-
"""face mesh.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1V9wV6AdrzgvtJcT-nJKOzWII-eazBDTB
"""

import cv2
import mediapipe as mp
from google.colab.patches import cv2_imshow
import numpy as np

img = cv2.imread("/content/bahram.jpg")
imgRGB = cv2.cvtColor(img , cv2.COLOR_BGR2RGB)
mpDraw = mp.solutions.drawing_utils
mpFaceMesh = mp.solutions.face_mesh
facemesh = mpFaceMesh.FaceMesh()
drawSpec =mpDraw.DrawingSpec(thickness = 1 ,circle_radius=1 , color=(0,255,0) )

results= facemesh.process(imgRGB)

if results.multi_face_landmarks:
  for faceLms in results.multi_face_landmarks:
    mpDraw.draw_landmarks(img , faceLms , mpFaceMesh.FACEMESH_CONTOURS , drawSpec, drawSpec)
    for id , lm in enumerate(faceLms.landmark):
      ih , iw , ic = img.shape
      x,y = int(lm.x*iw) , int(lm.y*ih)
      print(id , x,y)


cv2_imshow(img)

import cv2
import mediapipe as mp
from google.colab.patches import cv2_imshow
import numpy as np

# /////////////////////////////////////////
# facemesh Module
class FaceMeshDetector():
  def __init__(self , static_image_mode =False , max_num_faces =2 ,refine_landmarks=False,
              min_detection_confidence = 0.5 , min_tracking_confidence = 0.5):
    self.static_image_mode = static_image_mode
    self.max_num_faces = max_num_faces 
    self.refine_landmarks = refine_landmarks
    self.min_detection_confidence = min_detection_confidence
    self.min_tracking_confidence = min_tracking_confidence

    self.mpDraw = mp.solutions.drawing_utils
    self.mpFaceMesh = mp.solutions.face_mesh
    self.facemesh = self.mpFaceMesh.FaceMesh(self.static_image_mode , self.max_num_faces ,
                                             self.refine_landmarks,self.min_detection_confidence ,self.min_tracking_confidence )
    self.drawSpec =self.mpDraw.DrawingSpec(thickness = 1 ,circle_radius=1 , color=(0,255,0) )

  def findFaceMesh(self , img , draw=True):
    self.imgRGB = cv2.cvtColor(img , cv2.COLOR_BGR2RGB)
    self.results= self.facemesh.process(self.imgRGB)
    if self.results.multi_face_landmarks:
      for faceLms in self.results.multi_face_landmarks:
        self.mpDraw.draw_landmarks(img , faceLms , self.mpFaceMesh.FACEMESH_CONTOURS , self.drawSpec, self.drawSpec)
        face =[]
        for id , lm in enumerate(faceLms.landmark):
          ih , iw , ic = img.shape
          x,y = int(lm.x*iw) , int(lm.y*ih)
          
          cv2.putText(img , str(id) , (x,y) , cv2.FONT_HERSHEY_PLAIN , 0.5, (255,0,0) , 1)

          # print(id , x,y)
          face.append([x,y])
    return img,face

def main():
  img = cv2.imread("/content/bahram.jpg")
  detector = FaceMeshDetector()
  img,face = detector.findFaceMesh(img , False)
  
  cv2_imshow(img)

if __name__=="__main__":
  main()

import cv2
import mediapipe as mp

# Face Mesh
mp_face_mesh = mp.solutions.face_mesh
face_mesh = mp_face_mesh.FaceMesh()

# Image
a = "hitfilm/IMG_20210512_160934.jpg"
image = cv2.imread("/content/bahram.jpg")
# image = cv2.imread(a)
height, width, _ = image.shape
print("Height, width", height, width)
rgb_image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

# Facial landmarks
result = face_mesh.process(rgb_image)

for facial_landmarks in result.multi_face_landmarks:
    for i in range(1, 200):
        pt1 = facial_landmarks.landmark[i]
        x = int(pt1.x * width)
        y = int(pt1.y * height)

        cv2.circle(image, (x, y), 3, (255, 100, 0), 1)
        #cv2.putText(image, str(i), (x, y), 0, 1, (0, 0, 0))
# cv2.imwrite("cover.jpg", image)

cv2_imshow(image)

!git clone https://github.com/ZPdesu/SEAN.git

# Commented out IPython magic to ensure Python compatibility.
# %cd SEAN/

!git clone https://github.com/alirezalti/face_mesh_module.git

